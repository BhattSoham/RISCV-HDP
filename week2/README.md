# RISC-V based MYTH Workshop #

This is part of a workshop "RISC-V based MYTH" conducted by VLSI System Design.

This section will cover all the basics required related to RISC-V ISA. 

The following are as follows:

**RV Day 1**

***1. Introduction to RISC-V ISA and GNU compiler toolchain:***
   
  a. Introduction to RISC-V basic keywords.
  
  b. Labwork for RISC-V software toolchain.

  c. Integer number representation.

**RV Day 2**  

***2. Introduction to ABI and basic verification flow:***
   
  a. Application Binary Interface (ABI).
  
  b. Labwork using ABI function calls.

  c. Basic verification flow using Iverilog.

## RV Day 1 ##

**Introduction**

RISC-V instruction set architecture (ISA) is the language of the computer. So, the question arises how can our C program turn into a hardware representation? 

In simple words, it is three simple steps:

RISC-V architecture -> RTL Implementation -> Layout(qflow).

To explain it more simply, 

Write your 'C' program -> Execute by hardware -> Get the desired output.

![image1](/week2/task1/RISCV_to_layout.png)

Now to expand it, the answer is whenever we are writing any C program, that program is generally our "Source Code". That output of the source code will be converted into assembly language (or instructions) using any compiler. The compiler will turn our code into specific instructions through a ".exe" file. The job of the assembler is to take the instructions and convert them into binary numbers. The assembler then takes our .exe file and converts it into binary, which is termed the "machine language" or "machine code" (represented using logic '0's and '1's). The machine code will then be fed to the hardware and accordingly, it generates the output.

![image2](/week2/task1/apps_to_hardware.png)

![image3](/week2/task1/c_to_hw.png)

If we see the pictures given above, we can see the system software. The system software comprises of three parts, operating system, compiler, and assembler. If the hardware belongs to x86/ARM/MIPS/RISCV-V, then the instructions will also belong to the respective formats.

So, in summary:

C program -> Assembly language generated by the compiler (the hex part in the instructions will be converted to machine instructions) -> Machine language by assembler -> Hardware (integrated the machine language into chip layout).

Another thing is, that the instructions are called the "Abstract Interface". They are generally the connector between the C program and RISC-V hardware. 

Another interface is the HDL language or the Hardware Description language. That is, implementation of the instructions). The next part is the synthesis into netlists of RTL (From logic gates, F/Fs, etc) and then the final part is the physical design implementation of the netlist (Hardware). That is the complete RTL to GDS flow.

![image4](/week2/task1/using_rtl.png)

a. Introduction to RISC-V basic keywords:

Regarding the RISC-V basic keywords, we have to keep in mind 5 things:
 i) Pseudo instruction.
 ii) Base integer instructions (RV64I, RV32I) -> Based on the 32/64 bit data.
 iii) FLoating point extensions (RV64F: Single-precision formats, RV64D: Double-precision formats)
 iv) Multiply/Division Extension (RV64M)
 v) Application Binary Interface (ABI)

 What are Pseudo Instructions: 

