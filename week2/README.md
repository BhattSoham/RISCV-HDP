# RISC-V based MYTH Workshop #

This is part of a workshop "RISC-V based MYTH" conducted by VLSI System Design.

This section will cover all the basics required related to RISC-V ISA. 

The following are as follows:

**RV Day 1**

***1. Introduction to RISC-V ISA and GNU compiler toolchain:***
   
  a. Introduction to RISC-V basic keywords.
  
  b. Labwork for RISC-V software toolchain.

**RV Day 2**  

***2. Introduction to ABI and basic verification flow:***
   
  a. Application Binary Interface (ABI).
  
  b. Labwork using ABI function calls.

  c. Basic verification flow using Iverilog.

## RV Day 1 ##

**Introduction**

RISC-V instruction set architecture (ISA) is the language of the computer. So, the question arises how can our C program turn into a hardware representation? 

In simple words, it is three simple steps:

RISC-V architecture -> RTL Implementation -> Layout(qflow).

To explain it more simply, 

Write your 'C' program -> Execute by hardware -> Get the desired output.

![image1](/week2/task1/RISCV_to_layout.png)

Now to expand it, the answer is whenever we are writing any C program, that program is generally our "Source Code". That output of the source code will be converted into assembly language (or instructions) using any compiler. The compiler will turn our code into specific instructions through a ".exe" file. The job of the assembler is to take the instructions and convert them into binary numbers. The assembler then takes our .exe file and converts it into binary, which is termed the "machine language" or "machine code" (represented using logic '0's and '1's). The machine code will then be fed to the hardware and accordingly, it generates the output.

![image2](/week2/task1/apps_to_hardware.png)

![image3](/week2/task1/c_to_hw.png)

If we see the pictures given above, we can see the system software. The system software comprises of three parts, operating system, compiler, and assembler. If the hardware belongs to x86/ARM/MIPS/RISCV-V, then the instructions will also belong to the respective formats.

So, in summary:

C program -> Assembly language generated by the compiler (the hex part in the instructions will be converted to machine instructions) -> Machine language by assembler -> Hardware (integrated the machine language into chip layout).

Another thing is, that the instructions are called the "Abstract Interface". They are generally the connector between the C program and RISC-V hardware. 

Another interface is the HDL language or the Hardware Description language. That is, implementation of the instructions). The next part is the synthesis into netlists of RTL (From logic gates, F/Fs, etc) and then the final part is the physical design implementation of the netlist (Hardware). That is the complete RTL to GDS flow.

![image4](/week2/task1/using_rtl.png)

**a. Introduction to RISC-V basic keywords:**

Regarding the RISC-V basic keywords, we have to keep these things in mind:
 i) Pseudo Instruction.
 ii) Base Integer Instructions (RV64I, RV32I) -> Based on the 32/64 bit data.
 iii) Floating Point Extensions (RV64F: Single-precision formats, RV64D: Double-precision formats)
 iv) Multiply/Division Extension (RV64M)
 v) Application Binary Interface (ABI)
 vi) Memory Allocation and Stack Pointer

***i) Pseudo Instructions:***

![image5](/week2/task1/Pseudo_instructions.png)

These instructions are move("mv"), load-immediate("li"), and return("ret"); highlighted by yellow in the picture given above.

***ii) Base integer instructions (RV64I, RV32I)***

![image6](/week2/task1/RV64I.png)

These instructions are termed "Base integer instructions". They are associated with integer addition, jump, store, etc. They are highlighted with a red arrow in the previous picture. They are dependent upon 32 or 64 bits of data and that's why, we can choose the right instruction format for RV32I and RV64I respectively.

***iii)  Floating point extensions***

![image7](/week2/task1/RV64F_&_RV64D.png)

They are of two types. One is for single-precision format (RV64F) and the other is for double-precision format (RV64D).

***iv) Multiply/Division Extension (RV64M)***

![image8](/week2/task1/RV64M.png)

These are the instructions used for multiply or division formats for RISC-V architecture.

***v) Application Binary Interface (ABI)***

![image9](/week2/task1/ABI.png)

The keywords presented using yellow color are for the application programmers who can use these registers directly for their RISC-V specification using those interfaces. These are called "Application Binary Interface" or "ABI". Every register is associated with some starting address. 

***vi) Memory allocation and stack pointer***

![image10](/week2/task1/Mem_allocation.png)

In every instruction, some data transfer occurs between memory, stack pointer, and register. This concept is called "Memory allocation and stack pointer".

**b. Labwork for RISC-V software toolchain:**

Let us take a simple C program to add and calculate the sum of numbers 1 to n. So for that, let us write the program on 'text editor' or use the command:
```
~ leafpad sum.c
```
The code is given below:
```
~ gcc sum.c
~./a.out
```
We can check the following result using gcc compiler in the below image.

![image11](/week2/task1/sum/using_gcc.png)

Now, in the RISCV64 software toolchain, we can compile our code using the following commands: 
```
~ riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum.o sum.c
```
To see the assembly instructions used for our code, we will use this command:
```
~ riscv64-unknown-elf-objdump -d sum.o | less
```
![image12](/week2/task1/sum/main.png)

Here, we can see the base address of our main function is 0000000000010184. If we subtract it from 00000000000101b0 and divide it by 4 (as byte instructions always increment by 4), we will get our number of instructions used, which is 11. 

Also, to get more optimized instructions,  we can use the following command by interchanging "O1" with "Ofast".
```
~ riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum.o sum.c
```
***SPIKE simulation and debug:***

SPIKE is a functional RISC-V ISA C++ sofware simulator. Spike is a debugger too, it can be invoked to debug an assembly code, just like any high-level language debugger. We can add breakpoints in terms of memory addresses reported in the leftmost column of the ASM code. To see the same output as gcc compiler using the SPIKE simulator, we will use the following command:
```
spike pk sum.o
```
![image13](/week2/task1/sum/using_spike.png)

For debugging, we will use the following command:
```
spike -d pk sum.o
```
Please check the below picture.

![image14](/week2/task1/sum/debug.png)

Let's imagine we wish to examine the content of the RISCV registers when main() is called. 
What is the content of register a2 when the main function is called?
To answer this question, we need to run the debugger. 

Command to invoke the spike debugger: 
```
~ spike -d pk sum1ton.o
~ till pc 0 100b0 
~ reg 0 a2 
```

## RV Day 2 ##

**Introduction to ABI**

"ABI" or "Application Binary Interface is an interface between two binary program modules in computer software.
The application programmer can directly access the registers of the RISC-V architecture or the hardware resources via a system call and this way is called the Application Binary Interface (ABI) or System Call Interface.

The below picture is detailed regarding the interfaces used from the application program to the hardware. The RISC-V hardware resources can be accessed by the operating system via User and system ISA. The user or the programmer can also access the hardware resources using System ISA.

![image15](/week2/task2/ABI_detailed.png)

If the programmer wants to know the hardware resources of our processor, it has to be done via registers. 

![image16](/week2/task2/ABI_to_Reg.png)

Now, we need to understand the architecture of the registers provided by RISC-V. We have 32 registers for RISC-V architecture. And, the width of the register is defined by the key "XLEN". It is 32 bits for RV32 and 64 bits for RV64.

![image17](/week2/task2/RISCV_reg.png)

Now the question arises, why do we need 32 registers only and how does the ABI access the resources of the processor via registers?

Now, let's take an example given in the below figure. The data provided there is a 64-bit data. So, for storing the 64-bit data in the registers, there are two options. The first one is to store it directly in the memory, which has a limited storage capability due to the 32-bit registers. The next option is to store the data in the registers from memory. The memory can hold 8 bits or 1 byte of data. 

![image18](/week2/task2/Process_of_data.png)

For the given data, it will be split into 8 parts. The first part will go to the LSB and thereby, moving towards the MSB. This process is called the "Little-endian memory addressing system". There's another one for the memory allocation which is called the "Big-endian memory addressing system", where the first part will go to the MSB and thereby move towards the LSB. That is the reverse of the "Little-endian" system.

But RISC-V belongs to the Little-endian memory addressing system".

![image19](/week2/task2/little_endian_memory.png)

1 double word is equal to 32 bits or 4 bytes. From the next picture, it can be concluded, if the address of the first doubleword is m[0]. the address of the second double word will be m[8] and so on.

![image20](/week2/task2/doubleword_2.png)

**LOAD INSTRUCTION**

Let's assume there's an array of 3 doublewords, it will start from m[16].

![image21](/week2/task2/doubleword.png)

Let's say we have to load the value to reg x8. So for that, we have to determine our base address which is x[23], and let it have 0 initially. The command to use it is the "load" command. What the load command does is that it loads the value of the x23 from the memory adding 16 (which is the offset) and stores it back to the register x8. 

![image22](/week2/task2/load.png)

Every instruction in RISC-V is 32 bits, be it a 32-bit register or a 64-bit register. So the 32-bit instruction format of the load command is given below.

![image23](/week2/task2/load_inst_format.png)

**ADD INSTRUCTION**

Another instruction is the "Add" command. To write it, we can present it like this 

![image24](/week2/task2/add.png)

Here, the content of x8 and x24 is added and stored to the reg x8. The 32-bit instruction format through which we can say the computer to do the add command is given below.

![image25](/week2/task2/add_inst_format.png)

**STORE INSTRUCTION**

Another instruction is the "store" command. Here the contents of the reg will be stored back to the memory. It is important because we have a limited number of registers for RISC-V and we have to store it continuously to the memory as it can store more amount of data.

![image26](/week2/task2/store.png)

The 32-bit instruction format for the same is given below.

![image27](/week2/task2/store_inst_format.png)

**Concluding 32-bit registers and their ABI names**

First of all, we have discussed only 3 instructions from the 47 RISC-V instructions. These "load", store" and "add" commands are called "Base Integer Instructions" (RV64I).

![image28](/week2/task2/Base_instructions.png)

Now, the add instruction is an R-type instruction because all the operations are associated with registers.

![image29](/week2/task2/R-type.png)

For the load instruction, it is I-type instruction as the name suggests "Immediate". It is associated with immediate or offset and register operations.

![image30](/week2/task2/I_type.png)

In the case of store instruction, it is S-type instruction as it is associated with only source registers.

![image31](/week2/task2/S_type.png)

Now our previous question was why it is only 32 registers for the RISC-V architecture. The answer is for every register, be it the source or destination, each one is 5 bits to be represented. For that reason, we have 2<sup>5</sup> = 32 integer registers for RISC-V architecture (because to represent the number of bits, we use 2<sup>n</sup>).

![image32](/week2/task2/why_32_reg.png)

The naming convention for the RISC-V registers is 0 to 31. Why? Given in the below figure. For this reason, it is [x0 to x(2<sup>5</sup> - 1)] or [x0 to x31.]

![image32](/week2/task2/patterns.png)

Now the ABI does a system call via these registers. 

![image33](/week2/task2/ABI_via_reg.png)

And it does like this:

![image34](/week2/task2/ABI_names.png)

These are the ABI names through which the programmer accesses the RISC-V CPU core.

![image35](/week2/task2/ABI_names_2.png)




